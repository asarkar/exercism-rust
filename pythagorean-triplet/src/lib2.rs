use std::collections::HashSet;

/*
 * a^2 + b^2 = c^2
 * => c^2 - b^2 = a^2 ---(i)
 * a + b + c = n
 * => b = n - a - c ---(ii)
 *
 * Substituting 'b' from equation (ii) into equation (i), we get:
 * c^2 - (n - a - c)^2 = a^2
 * => c^2 - (n - a - c) * (n - a - c) = a^2
 * => c^2 - n(n - a - c) + a(n - a - c) + c(n - a - c) = a^2
 * => c^2 - n^2 + an + nc + an - a^2 - ac + cn - ac - c^2 = a^2
 * => -n^2 + 2an + 2nc - a^2 - 2ac = a^2
 * => -n^2 + 2an + 2nc - 2a^2 - 2ac = 0
 * => 2c(n - a) = n^2 - 2an + 2a^2
 * => c = (n^2 - 2an + 2a^2) / 2(n - a)
 *
 * Since n - a > 0, a < n.
 *
 * For c to be a positive integer, (n^2 - 2an + 2a^2) must be
 * positive and perfectly divisible by 2(n - a).
 *
 * We iterate for a in [1, n), and check for the above condition.
 *
 * This solution doesn't work for the given problem because the 
 * triples generated by Euclid's formula is primitive if and only if m and n are coprime and one of them is even. 
 */
pub fn find(sum: u32) -> HashSet<[u32; 3]> {
    let mut triplets = HashSet::new();
    let x = sum * sum;
    let y = 2 * sum;

    for a in 1..sum {
        let denom = (2 * (sum - a)) as f64;
        let i = (y * a) as f64;
        let j = (a * a) as f64;
        let num: f64 = (x as f64) - i + 2.0 * j;
        let k: f64 = num / denom;

        if num > 0.0 && k.fract() == 0.0 {
            let c = k as u32;
            if sum < a + c {
                continue;
            }
            let b = sum - a - c;
            if b > a && b < c {
                triplets.insert([a, b, c]);
            }
        }
    }
    triplets
}
